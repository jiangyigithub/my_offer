## 操作系统整体
### 什么是操作系统？
操作系统管理计算机的硬件资源，并为应用程序提供抽象。
操作系统相当于应用程序和计算机硬件之间的中间层。

### 操作系统的主要目的/作用
管理计算机的硬件资源，并为应用程序提供抽象。
包括进程的抽象、虚拟地址空间的抽象、文件系统的抽象。
还有一个是提供图形界面。

### 什么是内核
操作系统常驻内存的部分（CSAPP 中的定义）


## 进程/线程
### 什么是进程
进程就是执行中的程序的实例。

### 什么是进程表
操作系统维护一个进程表，来跟踪每个进程的活动状态，进程表中包括进行的状态、进程使用的资源等信息。

### Linux 中如何创建进程？创建进程后如何区分子进程？
使用 fork() 函数创建进程，fork 函数调用一次返回两次，在子进程中的返回值是 0，在父进程中返回值是子进程的 PID，所以可以根据返回值是否为 0 来区分子进程。

### fork 创建的子进程继承了父进程的哪些内容？
继承了父进程中所有的用户虚拟地址空间的部分，包括代码、数据、堆、共享库、栈，此外还继承了父进程的打开的文件描述符、页表、进程表等。

### Linux进程地址空间分布
一个进程会有一个独立的虚拟地址空间，虚拟地址空间从底往上依次是代码段、数据段、堆、共享库映射区域、栈，再往上就是内核级区域了。其中栈是从虚拟地址空间的顶部向下增长的，堆则是向上。

### 什么是僵尸进程？
就是已经终止了但还没有被回收的进程。

### 解释孤儿进程，僵死进程
如果一个子进程在终止之前它的父进程已经终止了，这是它就变成了孤儿进程，就需要由 PID 为 1 的最终父进程来回收它。
僵尸就是已经终止了但还没有被回收的进程。

### 解释惊群效应
惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。
实际场景中可能产生惊群的地方：
服务器多个进程通过 accept() 函数等待连接：Linux 内核会保证只唤醒一个进程的 accept，因此不会产生惊群效应。
多线程的惊群。
产生性能浪费的地方：对进程/线程进行频繁的无用的上下文切换。为了确保只有一个进程/线程得到资源，还需要为资源操作进行加锁。
解决惊群效应的方法：锁机制是一种常见的方法，通过加锁使得任意时刻只有一个进程/线程等待

### 进程有哪几种状态
运行、阻塞、就绪三种状态。

### 如何避免 fork 创建的子进程继承父进程打开的文件描述符？
clone() 函数可以有选择地复制父进程的资源。而 fork() 则是全部复制。
或者及时在子进程中关闭继承来的文件描述符。

### 什么是线程
线程是进程中的单条流向。是程序执行的最小单位。
Linux 中线程实际上就是轻量级的进程。

### 进程和线程的区别
进程是系统进行资源分配和调度的一个独立单位，线程是进程中的单条流向，是程序执行的最小单位。
一个进程可以有多个线程，不同线程之间并发运行。
进程管理的资源要比线程多很多。
每个进程有独立的地址空间、全局变量、信号与信号处理程序、打开的文件描述符等。线程中则主要包括程序计数器、寄存器、堆栈等，而同一进程的不同线程则会共享同样的内存地址空间、代码段、数据段、打开的文件描述符集合等。
创建进程的开销比创建线程大很多。进程切换也比线程切换的开销高很多。

### 多线程共享什么数据
进程的代码段、数据段、打开的文件描述符、信号处理函数等。

### 什么是协程
协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。
进程和线程的切换都是由操作系统管理的，而协程是完全由程序所控制。
协程不是进程也不是线程，而是一个特殊的函数，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。
一个线程的多个协程的运行是串行的（或者说并发但不并行），没法利用CPU多核能力。
协程的切换者是用户（编程者或应用程序），切换时机是用户自己的程序所决定的。协程切换时主要是切换寄存器的内容，切换下来的数据保存在用户栈或堆中。协程的切换过程只有用户态，即没有陷入内核态，因此切换效率高。
C++ 语言本身目前还不支持协程，但有一些库如 libco， co 库可以实现协程。协程在 go 语言中应用很广。


## 进程间通信
### 常见的进程间通信方式
* 匿名管道：管道是半双工的通信方式，全双工的话需要同时使用两个管道。速度慢，容量有限，只有父子进程或具有相同父进程的两个子进程间能通讯。
* 先进先出队列 FIFO（命名管道）。任何进程间都能通讯，但速度慢。
* 共享内存。能够很容易控制容量，速度快，但要保持同步。
* 信号量。只能用来同步。
* 消息队列。容量受到系统限制。
* 信号。
* socket
其中共享内存、信号量、消息队列都属于系统 IPC。

### 讲一下管道
管道是一种进程间通信方式。以半双工方式工作。通过 pipe 函数创建。
通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道
管道只有父子进程或具有相同父进程的两个子进程间。一个管道只能用于一个方向的数据传输。父子进程其中一方必须关闭 fd[0]，另一方关闭 fd[1]。
管道有对应的读写文件描述符，fd0 是读，fd1 是写。可以将管道当作文件来进行读写。但是管道不存在于文件系统中，只存在于内存中。
linux 命令中的 | 就是使用了匿名管道，这个管道是由 shell 程序创建的，各命令都是 shell 的子进程。
int fd[2];
pipe(fd);
所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。

### 讲一下FIFO
FIFO 即有名管道。
FIFO 可以在无关的进程间交换数据。
FIFO有路径名与之关联，以一种特殊设备文件的形式存在于文件系统中。
一旦创建了一个 FIFO，就可以用一般的文件I/O函数操作它
FIFO的通信方式类似于用文件来传输数据，只是FIFO类型文件具有管道的特点，在数据读出时FIFO管道清除数据，并且“先进先出”。
FIFO 速度很慢。
不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。
mkfifo test // mkfifo 命令可以用来创建管道

### 讲一下消息队列
消息队列是保存在内核中的消息链表，一个队列由一个队列ID标识
消息队列中的消息有特定的格式和特定的优先级（有不同类型的消息）
消息队列独立于发送和接收进程。进程终止，消息队列及内容并不会删除
消息队列可实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息类型读取
消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，
消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。

### 共享内存
两个或多个进程共享一个给定的存储区。共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。
共享内存是最快的一种 IPC
信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

### 讲一下信号量
信号量是个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作
每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数

### 讲一下信号
对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。
信号是进程间通信机制中唯一的异步通信机制，因为可以在任何时候发送信号给某一进程。
Ctrl+C 产生 SIGINT 信号，表示终止该进程；
Ctrl+Z 产生 SIGTSTP 信号，表示停止该进程，但还未结束；
如果进程在后台运行，可以通过 kill 命令的方式给进程发送信号。

### 讲一下socket
将 socket 的第一个参数设置为 AF_LOCAL/AF_UNIX 可以进行本机不同进程之间的通信。
本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件。
同一个主机不同进程间通过 socket 通信不需要经过网卡，但是需要经过 TCP/IP 协议栈的一系列封装过程。

### 最快的进程间通信方式是什么？
共享内存，因为它不涉及进程间的任何数据传输，各个进程通过访问一段共享的内存来实现通信。缺点是需要进行进程同步。

### 共享内存为什么比其他的进程间通信方式快？
两个进程通过共享内存进行通信只有写内存和读内存两个步骤。

### 处理共享内存的函数
shmget, shmat, shmdt, shmctl 等函数
shmget：创建或获取一段共享内存。
shmat：将共享内存与进程的地址空间相关联。关联后进程才能访问共享内存
shmdt：将共享内存从进程地址空间中分离。
shmctl：修改共享内存的属性。

### 重启进程后，原共享内存是否可以操作？对于普通的进程又是如何呢？


## 多线程同步
### 线程安全概念
线程安全其实是指内存的安全。
当多线程对一块公共内存进行操作时，不会发生数据被意外修改的情况。
多线程中涉及到的公共内存主要是共有的堆内存和全局数据区。

### 线程安全解决方案概述
将线程自己的数据保持私有。
把数据复制 N 份，每个线程认领一份，只操作自己那份数据。
使用锁机制独享数据的读写权。
低并发情况下，使用乐观锁。

### 乐观锁的使用
在并发写的并发量不高的情况下，可以使用乐观锁。
着使用了 CAS（Compare and Swap） 策略。即在线程第二次操作数据的时候，将数据和自己上一次操作数据的结果相比较，看看数据是否被修改，如果被修改了，那就撤销之前的操作，从头开始处理。
一般会给数据增加版本号，即每次修改数据都要增加数据的版本号，线程通过判断数据的版本号来判断数据是否被修改过。

### 线程同步机制
互斥锁、信号量、条件遍历、原子操作等。
还要基于互斥锁的读写锁。

### 什么是互斥锁
某一个进程在访问一项资源时，禁止其他进程同时访问该资源。

### 什么是线程安全？什么是可重入函数？
当多线程同时执行同一操作而不会产生问题时该操作就是线程安全操作。可重入函数就是线程安全函数。

### Linux 互斥锁里面递归锁和非递归锁的使用方式，返回值。
默认情况下是非递归锁。
可以通过设置互斥锁的 PTHREAD_MUTEX_RECURSIVE 属性将其修改为递归锁。
递归锁是可重入锁，非递归锁又叫不可重入锁。 
同一个线程可以多次获取同一个递归锁，不会产生死锁。如果一个线程多次获取非递归锁，可能会产生死锁。
应该尽量避免使用递归锁，使用递归锁可能发生竞态条件。

### 讲一下多线程什么时候需要同步？
当存在临界区的时候，即多个线程同时访问某共享的资源或变量时。
需要对线程同步，以确保任意时刻只有一个线程能进入临界区。
多线程同步的常用工具：互斥锁、信号量、条件变量、读写锁。

### 线程池要分配多少个线程
根据情况确定，简单来说，CPU 密集型的应用分配 N+1 个线程。
IO 密集型应用根据线程的等待时间来分配线程，保证充分利用 CPU 即可。

### 临界区问题
每个进程中访问临界资源的那段代码称为临界区（Critical Section）（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。
多个进程中涉及到同一个临界资源的临界区称为相关临界区。

### 多线程中各概念的关系
核心矛盾是“竞态条件”，即多个线程同时读写某个字段。
竞态条件下多线程争抢的是“竞态资源”。
涉及读写竟态资源的代码片段叫“临界区”。
保证竟态资源安全的最朴素的一个思路就是让临界区代码“互斥”，即同一时刻最多只能有一个线程进入临界区。
最朴素的互斥手段：在进入临界区之前，用if检查一个bool值，条件不满足就“忙等”。这叫“锁变量”。
但锁变量不是线程安全的。因为“检查-占锁”这个动作不具备“原子性”。
“TSL指令”就是原子性地完成“检查-占锁”的动作。
就算不用TSL指令，也可以设计出线程安全的代码，有一种既巧妙又简洁的结构叫“自旋锁”。当然还有其他更复杂的锁比如“Peterson锁”。
但自旋锁的缺点是条件不满足时会“忙等待”，需要后台调度器重新分配时间片，效率低。
解决忙等待问题的是：“sleep”和“wakeup”两个原语。sleep阻塞当前线程的同时会让出它占用的锁。wakeup可以唤醒在目标锁上睡眠的线程。
使用sleep和wakeup原语，保证同一时刻只有一个线程进入临界区代码片段的锁叫“互斥量”。
把互斥锁推广到"N"的空间，同时允许有N个线程进入临界区的锁叫“信号量”。
互斥量和信号量的实现都依赖TSL指令保证“检查-占锁”动作的原子性。
把互斥量交给程序员使用太危险，有些编程语言实现了“管程”的特性，从编译器的层面保证了临界区的互斥，比如Java的synchronized关键字。
并没有“同步锁”这个名词，Java的synchronized正确的叫法应该是“互斥锁”，“独占锁”或者“内置锁”。但有的人“顾名思义”叫它同步锁。

## 进程调度算法
### 进程调度算法基础
进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。
当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。
发生 CPU 调度的情况：
1. 当进程从运行状态转到阻塞状态；
2. 当进程从运行状态转到就绪状态；
3. 当进程从阻塞状态转到就绪状态；
4. 当进程从运行状态转到终止状态；
其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。
非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。
而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。
你可能会好奇为什么第 3 种情况也会发生 CPU 调度呢？假设有一个进程是处于等待状态的，但是它的优先级比较高，如果该进程等待的事件发生了，它就会转到就绪状态，一旦它转到就绪状态，如果我们的调度算法是以优先级来进行调度的，那么它就会立马抢占正在运行的进程，所以这个时候就会发生 CPU 调度。
那第 2 种状态通常是时间片到的情况，因为时间片到了就会发生中断，于是就会抢占正在运行的进程，从而占用 CPU。
调度算法影响的是等待时间（进程在就绪队列中等待调度的时间总和），而不能影响进程真在使用 CPU 的时间和 I/O 时间。

### 常见的调度算法：
先来先服务调度算法
最短作业优先调度算法
高响应比优先调度算法
时间片轮转调度算法
最高优先级调度算法
多级反馈队列调度算法


## 内存管理
### 程序的地址空间分布。
虚拟地址空间从底往上依次是代码段、数据段、堆、共享库映射区域、栈，再往上就是内核区域了。

### 什么是按需分页
按需分页是虚拟内存的一种管理方式，当程序需要访问某一页面时，才会分配该页面。
如果访问页面时该页面没有缓存到内存中，就会触发缺页异常。

### 什么是虚拟内存
虚拟内存是现代计算机最重要的几种抽象之一，它也是一种内存分配方案。虚拟内存采用按需分配。

### 什么是缓冲区溢出
缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。
这会造成未定义的后果，也是黑客攻击的一个漏洞。
它可能使程序崩溃，也可能执行一段恶意的代码。
详细介绍：缓冲区溢出攻击

### malloc 分配的是虚拟内存还是物理内存？
是虚拟内存，但是如果这一块虚拟内存之前并没有缓存到物理内存中，那会通过触发缺页异常将其映射到某一个物理内存区域

### memset 操作 malloc 的指针，是操作物理内存还是虚拟内存？
操作的是虚拟内存。在进程的虚拟地址空间中的堆区域分配内存。

### Linux内存管理方法，页面置换算法，逻辑地址和物理地址的转换


### 在一台内存为2G的机器上，malloc(20G)会怎么样？new 20G呢？
首先，malloc和new申请的都是虚拟内存
malloc函数的实质，有一个将可用的内存块连接起来的链表，调用malloc的时候，会沿着链表找一个满足用户需求的内存块。然后将这个内存块一分为二，一块和用户所申请的内存大小相同，另一块返回到链表中。如果用户申请一个大的内存块，空闲链表上可能没有可以满足用户要求的片段，这个时候malloc函数就会请求延时，对链表上的内存进行整理。如果还是不可以的话， 内存申请失败，返回 NULL
new 的话，底层实现还是malloc，在分配失败的时候会抛出bad_alloc类型的异常

### 什么是缺页异常？那种情况会导致缺页异常发生？

## 设备管理++
### 什么是 DMA
DMA 是直接内存访问，就是在 I/O 设备和内存之间进行数据传输时不需要通过 CPU 进行中转，这减轻了对总线的压力，提高了数据传输的效率。


## 死锁
https://zhuanlan.zhihu.com/p/26945588
### 出现死锁的情况
存在循环等待的情况时。进程 A 排他性地访问不可抢占资源 1，进程 B 排他性地访问不可抢占资源 2，进程 A 还要访问资源 2 才能完成执行，进程 B 还要访问资源 1 才能完成执行。然后进程 A 和进程 B 就会进入死锁地状态，它们会一直等待对方执行完毕。 

### 出现死锁必须满足的四个条件
互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

### 避免出现死锁的方式
破坏死锁出现的四个条件之一即可避免死锁出现：
避免互斥条件：如可以将资源给每个进程/线程拷贝一份。此方法使用较少。
破坏请求和保持条件：任何一个线程“贪心”，都可能会导致死锁。即占用了一个资源还没释放就要占用另一个资源。可以通过规定一个线程获取一项资源后，必须释放了资源才能请求另一项资源。
破坏不剥夺条件：给资源设置 ”最长占用时间“，当某个线程/进程占用该资源超过时限就强制释放资源。
破坏环路等待条件：死锁中必然存在 “环路等待”。可以约束各线程获取、释放资源的顺序，避免出现环路等待条件。

### 实际场景中产生死锁的情况
死锁产生的原因有很多，如：
进程顺序不当
PV操作使用不妥
同类资源分配不均
对某些资源的使用未加限制


### 处理死锁的策略
三种处理死锁的策略：
避免死锁。
检测死锁并恢复死锁。
忽略死锁的影响。

### 检测死锁的方式
如果进程 - 资源分配图中无环路，此时系统没有发生死锁。
如果进程 - 资源分配图中有环路，则可分为以下两种情况：
每种资源类中仅有一个资源，则系统必然发生了死锁。
每种资源类中有多个资源，则环路的存在只是产生死锁的必要不充分条件，系统未必会发生死锁。

### 恢复死锁的方式
资源剥夺法：依次剥夺进程占用的资源，直到死锁解除。
进程回退法：根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。

