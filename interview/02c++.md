
## 继承与多态

### 什么是虚函数？虚函数的作用？
在基类的定义中使用 virtual 关键字声明的函数就是虚函数。如果一个函数在基类中是虚函数，在派生类中也默认为虚函数。
虚函数是多态的实现方法，通过虚函数可以实现动态绑定，就是当通过类对象的指针或引用来调用虚函数时，会根据运行时指针或引用实际所关联对象的类型来调用相应的虚函数版本。

### 虚函数与非虚函数的区别？
在定义上，在类的定义中使用 virtual 关键字声明的函数就是虚函数。
在使用上，当通过基类的指针或引用
调用虚函数时会发生动态绑定。
一般将希望在派生类中重新定义的函数定义为虚函数。
虚函数的解析发生在运行时阶段，非虚函数的解析发生在编译阶段。
虚函数必须提供定义，不能只声明不定义（因为编译器不知道哪个虚函数会被用到）；而类的非虚成员函数可以只声明不定义。

### 虚函数的实现原理
编译器会为每一个定义了虚函数的类生成一个虚表，这个虚表中按照一定顺序存放了该类中所有虚函数的地址。
然后编译器会为该类的每一个对象都创造一个指向该虚表的指针。这个指针隐式地存在于该对象在内存中的存储空间中。
用一个具体的例子来阐述：基类 A 中定义了 f1, f2, f3 共三个函数，其中 f1, f2 是虚函数，f3 是非虚函数。那么对应的 A 的虚表中按序存放了 f1 和 f2 的地址。
然后派生类 B 继承了 A，并对 f2 函数进行了重定义，那么对应的 B 的虚表中也会按照和 A 一样的顺序存放 f1, f2 的地址，其中 f1 指向的还是基类 A 中 f1 的地址，而 f2 则指向 B 中重定义的 f2 的地址。
如果 B 中又新增了一个虚函数 f4，那么 f4 会添加到 B 的虚表中的最后，保证不会干扰到 f1 和 f2 在虚表中的位置。
这样当通过基类指针来调用虚函数时，如果指针绑定了一个基类对象，那么会通过虚表指针来找到虚表，并从虚表中找到对应函数的地址来调用该函数。如果绑定的是一个派生类对象，也会用同样的方式找到对应函数地址。因为在派生类和基类的虚表中，各虚函数的顺序是一致的，所以不论指针最后绑定了一个基类对象还是派生类对象，都能保证能够调用到正确的虚函数。

### 虚函数与纯虚函数的区别
在声明虚函数的语句后面加一个 =0 就变成了纯虚函数。包含纯虚函数的类是抽象基类，不能直接创建抽象基类的对象。
纯虚函数声明和定义是一体的，没有函数体。而虚函数则必须进行定义。

### 纯虚函数的实现原理
定义一个纯虚函数即告诉编译器在虚表中为它保留一个位置，但是这个位置中不放地址。因此类中只要有一个函数是纯虚函数，它的虚表就是不完全的，就无法创建一个抽象基类的对象。

### 虚表的内存结构布局，虚表的第一项是什么？
虚表中放了该虚表所属类的所有虚函数的地址。继承自基类的虚函数在最前面，派生类新增的虚函数在后面。其中前面继承自基类的虚函数在虚表中的位置与基类的虚表中对应虚函数的位置一样。
虚表的第一项是基类中声明的第一个虚函数。

### 讲一下单继承、多继承的虚表结构吧
单继承是派生类只有一个直接基类，多继承是派生类一次性继承多个直接基类。

父类中定义了一个虚函数，子类继承该虚函数，那么在内存中调用虚函数过程的机制是怎么样的？
用虚表来解释。

菱形继承（D 同时继承 B 和 C，B、C 都继承 A）中，虚表在各个类中的布局如何？如果类 B 和类 C 同时有一个成员变量 m，m 如何在 D 对象的内存地址上分布的？是否会相互覆盖？

什么是对象切片？
在未使用指针或引用时，如果对一个对象进行向上类型转换，会发生对象切片。
当一个函数以传值方式接受一个基类类型，而在调用该函数时却传递给它一个派生类的对象，编译器会接受这个实参，但只拷贝这个对象对应基类的部分，切除这个对象的派生类部分，即对象切片。
在对象切片过程中，编译器实际上将该对象视为一个基类类型，调用的也是基类的构造函数，将 VPTR 指向基类的虚表。

## 构造/析构函数
### 简单讲述构造函数与析构函数
构造函数是在构造类的对象时执行的函数，构造函数一般负责完成对象的初始化。
如果不主动声明或定义默认构造函数，编译器会为合成一个默认构造函数。
析构函数是销毁对象时执行的函数。

### C++的析构函数的触发机制和调用事项是否了解？
当销毁 C++ 的对象时会执行类的析构函数。
析构函数中不能调用虚函数，但是析构函数本身可以是虚函数。
不能让析构函数抛出异常，如果有异常要在析构函数内部处理完毕。

### 派生类构造析构函数的调用顺序
先执行最顶层的基类的构造函数，再按继承顺序依次执行派生类的构造函数。析构函数的执行顺序则与构造函数相反。

### 在构造函数中调用虚函数无法达到期望目的的原因
派生类的构造函数执行时会先调用基类的构造函数完成基类部分的初始化。在调用基类构造函数期间，对象会被视为是基类类型的，基类的构造函数也会将 VPTR 指向它自己的虚表。直到基类构造函数执行完毕，执行派生类的构造函数时才会将 VPTR 指向派生类的虚表。

### 拷贝构造、拷贝赋值函数在什么情况下实现？
可以根据一个简单原则：首先当需要定义拷贝构造函数时，基本也需要定义拷贝赋值函数，反过来也是一样。然后当需要定义析构函数时，基本也需要定义拷贝构造函数和拷贝赋值函数。
具体一下，典型的应用场景是类内有指向动态内存的成员时，需要定义这些函数。

### 为什么构造函数不能是虚函数而析构函数可以是呢

如果不加virtual，会按指针的类类型进行析构，也就是基类。delete时只释放基类，不释放子类；
如果加了virtual，会按指向类型进行析构，也就是子类。 然后析构子类的话会默认析构基类，delete时基类和子类都会被释放；
所以不加virtual可能会存在内存泄露的问题。

    不加 virtual 的析构函数：
        如果基类的析构函数不是虚函数，而你使用基类指针删除指向派生类对象的动态内存，只会调用基类的析构函数。这意味着只有基类的资源得到释放，派生类的资源不会被释放，可能导致派生类中分配的资源泄漏。

    加了 virtual 的析构函数：
        当基类的析构函数声明为虚函数时，使用基类指针删除指向派生类对象的动态内存时，会先调用派生类的析构函数，然后调用基类的析构函数。这确保了派生类的析构函数被正确地调用，从而释放了派生类及其基类所分配的所有资源，避免了内存泄漏。

通过使用虚析构函数，确保了正确的资源释放顺序，从而避免了潜在的内存泄漏问题。因此，当使用继承和多态时，通常建议将基类的析构函数声明为虚函数，以确保正确地释放派生类对象的资源。

构造函数不能是虚函数，而析构函数可以是虚函数，因为析构函数执行时已经知道对象的类型（构造期间则不然），它的 VPTR 也早已初始化完毕，可以执行正确的虚函数调用。

### 什么时候应该将析构函数定义为虚函数
应用准则：任何时候只要类中有一个虚函数，就应该定义一个虚析构函数。这可以避免后面发生问题。

### 为什么要使用虚析构函数
如果使用基类的指针指向了一个派生类的对象，并使用 delete 销毁这个指针时，如果析构函数是非虚函数，那么只会执行基类的析构函数，而当析构函数是虚函数时，则会执行对象实际类型的析构函数。

### 构造函数和析构函数可否为虚函数
构造函数不能是虚函数；
析构函数可以是虚函数。并且通常应该将基类的析构函数定义成虚函数。这样在 delete 一个类指针（类指针可能会发生动态绑定）时可以保证使用正确版本的析构函数。

### 构造函数可否调用虚函数，会有什么后果
语法上是可以的，但是在应用不应该这么做。
用一个例子来说明，假设 A 类的构造函数调用了一个虚函数，B 类继承了 A 类。在构造 B 类的对象时，B 类会首先通过调用 A 类的构造函数来构造其中属于 A 类的部分，这时在 A 类的构造函数中调用的虚函数的版本只会是 A 类中的版本，而不会是 B 类中的版本。
总结一下就是构造函数中调用的虚函数版本永远不会变成派生类中的版本，而只能是该基类中的版本。

### 析构函数可否调用虚函数
不能。当在析构函数中调用其他虚函数，这些虚函数只能执行本地的版本（就是当前析构函数所属类的虚函数版本）。
原因：析构函数是从外层向内（即从派生类向基类的方向）调用的。在内层的析构函数执行期间，外层派生类的成员已被销毁，此时执行派生类版本的虚函数会发生危险，因此只会执行虚函数的内层基类版本。
理解构造函数和析构函数采用同样方式对待虚函数的不同原因：构造函数中是因为类型信息（即 VPTR）还不可用，析构函数中是因为信息虽存在，但不可靠。

### 为什么很多人禁用拷贝（复制）构造函数(类成员变量包含指针，涉及到深拷贝和浅拷贝)
为解决深拷贝和浅拷贝的问题,可能会导致析构的时候两次删除同一片区域的问题。解决方案有三种：

1. 自己编写拷贝构造函数，然后在拷贝构造函数中创建新的buf_，不过拷贝构造函数的 编写需要考虑异常安全的问题，所以编写起来有一定的难度。
2. 使用 shared_ptr 这样的智能指针，让所有的 Widget 对象共享一片 buf_，并 让 shared_ptr 的引用计数机制帮你智能的处理删除问题。
3. 禁用拷贝构造函数和赋值操作符。如果你根本没有打算让Widget支持拷贝，你完全可 以直接禁用这两操作，这样一来，前面提到的这些问题就都不是问题了。
ref: http://blog.guorongfei.com/2016/04/24/why-delete-copy-constructor/


## STL容器 http://www.stlport.org/resources/StepanovUSA.html

### 讲一下 vector 和迭代器
定义：vector 是一种 STL 容器，属于顺序容器，从语法上来说它是一种类模板。
特点：vector 的特点是可以在尾部快速插入与删除，可以实现快速随机访问。
原理：vector 通过一个单向开口的连续数组来实现。在内存中会为 vector 对象分配一块大于等于它的内存，当 vector 增长到超过分配的内存时，就会再为它分配一块更大的内存，并将 vector 的内容复制过去。这个过程称作扩容，vector 扩容时，每次新分配的内存会是之前的两倍。
用法：访问 vector 的元素可以通过迭代器和下标，其中下标访问有可能越界，有时为了避免越界可以采用 at() 成员函数，使用 at 时如果下标越界，会抛出 out_of_range 异常。向 vector 中增加元素包括：push_back(), insert(), emplace() 三类。其中push_back() 是在尾部插入元素，时间复杂度为 O(1)。insert 和 emplace 可以在 vector 的任意位置插入元素。insert 和 emplace 的区别是 insert 直接插入一个元素类型对象的拷贝，emplace 则是传递构造元素类型对象的参数来构造一个新的元素。删除元素的方法有 pop_back() 和  erase() 两种。
此外还有如 capacity() 函数获取当前内存为 vector 分配的内存，shrink_to_fit() 请求将分配的内存缩小至与 vector 同大小等。 
应用：vector 是最常用的容器了，一般如果没有某个需求确实需要采用其他容器时，都可以用 vector 来完成。


### vector 中 resize() 和 reserve() 的区别
首先要区分  vector 对象本身和内存为 vector 分配的容量。
resize() 调整的是 vector 对象本身的大小。当然容量也会按照 vector 自身的容量变化机制随着对象的大小变化而变化。
reserve() 调整的是内存分配的容量的大小。

### vector原理
vector 中有 3 个迭代器，分别指向 vector 的首位置、尾后位置、当前分配空间的末尾位置。

### vector扩容机制了解吗？（扩容1.5倍或2倍，数据复制等）
向 vector 添加元素时，如果 vector 的可用空间已经用完，就会进行扩容。
vector 在 gcc 中一次扩容两倍，在 vs 中一次扩容 1.5 倍。如果一次插入了大量元素，导致扩容两倍后空间还不够，则会一次性扩容到足够空间。
扩容包括三个步骤：首先分配新空间，新空间的大小是旧空间的两倍或 1.5 倍，然后复制 vector 的元素，最后释放旧空间。

### 为什么每次vector都是以倍数扩容的
以倍数增长保证了 vector 的扩容次数是 logn 级别的，如果是按个数扩容，当要插入 vector 的数据量非常大时，扩容次数会非常多。

### 为什么 vector 按 1.5 或 2 倍来扩容
通过数学分析一下，在对内存的浪费和扩容次数间取了一个均衡。

### vector 和 list 的区别？
vector 的顺序结构，在内存中占用的是连续线性空间。vector 可以快速随机访问，时间复杂度为常数级别。
list 是链表结构，在内存中占据的空间是离散的。list 只能顺序访问，时间复杂度 O(n) 级别。

### 访问 vector 的迭代器时可以删减元素吗？list 呢？
可以通过 vector 的迭代器来删除元素，但是删除元素后指向该元素之后的位置的迭代器会失效。
list 则不会。

### vector 的底层实现原理？
底层是通过顺序数组+扩容来实现的。

### deque的原理
deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。deque 容器用数组（假设叫做 map）存储着各个连续空间的首地址。

### deque的扩容机制
当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。
如果 map 数组满了，再申请一块更大的连续空间供 map 数组使用，将原有数据（很多指针）拷贝到新的 map 数组中，然后释放旧的空间。

### deque的迭代器
迭代器要能够实现在不同的连续空间中移动。
迭代器内部包含 4 个指针，它们各自的作用为：
cur：指向当前正在遍历的元素；
first：指向当前连续空间的首地址；
last：指向当前连续空间的末尾地址；
node：它是一个二级指针，用于指向 map 数组中存储的指向当前连续空间的指针。

### deque 的底层实现
deque 中有两个迭代器成员：start 和 finish，一个指向首个元素，一个指向尾后位置。

### map底层实现是什么？
红黑树

### 红黑树讲一下，怎么翻转？ 
红黑树是一种二叉平衡树。

### 红黑树的特点？
所有黑色节点到根节点的距离是一样长的。

### 常见的二叉平衡树有哪些？
红黑树、B树。

### unordered_map底层实现是什么？ 和map有什么区别，谈谈优劣势
哈希表。
map 的主要优点是它的元素是有序的。
unordered_map 的优点是插入和查询的平均时间更快，但是占用空间略大一些，不过一般影响不大。
map 的插入和查询时间复杂度都是 O(logn)。

### string的底层原理
当 string 中的字符串大小不超过 15 字节时，是存储在栈中的，string 在栈中预分配了 15 字节的大小，即使字符串小于 15 字节，分配的空间一样是 15 字节。
当 stirng 中的字符串大小超过 15 字节，就会在堆上分配内存。
string 对小字符串的处理被称为小型字符串优化。

### string的扩容机制
当 string 中的字符串放到了堆上时，是和 vector 的扩容机制一样的。

### string相比字符数组的缺点
有些浪费空间。string 是一种类，即使 string 是空的，它的大小也是 32 字节。

### list 底层实现原理
list 底层是链表结构。

### 都用过哪些STL容器？
顺序容器用过 string、vector、list、array、deque、forward_list 等，关联容器用过 map、unordered_map、set、bitset 等，然后三种容器适配器 stack、quque、priority_queue 也都用过。
vector：底层是一个顺序存储的连续数组，单项开口，可以在尾部快速插入与删除，可以通过下标实现 O(1) 的快速随机访问。
deque：底层是连续或分段连续的数组，双向开口，可以在头部和尾部快速插入与删除。可以实现快速随机访问。
list：链式存储，底层是一个双向环状链表。无法随机访问，只能双向顺序访问，优点是可以快速插入或删除链表中的任意一个元素。因为每个元素中都要存储指向前后节点的指针，所以占用的空间大一些，相对适合存储那种单个元素体积比较大的类型。
forward_list：链式存储，底层是一个单向链表。无法随机访问，只能单向顺序访问。
array：底层是一个固定大小的连续数组。对象在创建时大小就确定了，不能插入与删除。可以快速随机访问。
string：可以在尾部快速插入与删除。
map、set、multimap、multiset：关联容器，元素是有序的，底层是红黑树。
unordered_map、unordered_multimap：无序容器，底层是哈希表。插入、删除、访问元素的速度更快一些。
stack：容器适配器，默认基于 deque 实现，先入后出。
queue：容器适配器，默认基于 deque 实现，先入先出。
priority_queue：容器适配器，默认基于 vector 实现，是一个堆。

### 迭代器的失效
迭代器失效指的是当容器发生结构上的变化时，迭代器可能会变得不再指向有效的元素或失去指向元素的能力。这可能导致程序运行时出现未定义的行为，甚至崩溃。

常见的迭代器失效情况包括：

    序列式容器的元素插入和删除：在 vector、deque、list 等序列式容器中，插入或删除元素会导致已有元素的移动，可能会使得原本指向某个元素的迭代器失效。这是因为容器的元素在内存中的位置发生了改变。

    关联式容器的元素插入：在 set、map 等关联式容器中，由于元素的插入通常不会导致容器内部结构的变化，迭代器不会失效。

    无序关联式容器的元素插入和 rehash：在 unordered_set、unordered_map 等无序关联式容器中，插入元素时，如果触发了容器的 rehash 操作（例如，当容器的负载因子超过了设定的阈值），则所有迭代器都会失效，因为 rehash 可能导致元素重新分布到不同的存储桶中。

为了避免迭代器失效导致的问题，需要谨慎地管理迭代器的生命周期，并遵循容器操作的规范。通常情况下，可以通过避免在迭代器仍然活跃的情况下对容器进行结构性的修改来减少迭代器失效的可能性，或者在必要时重新获取迭代器。


## Mordern
### C++11新特性
C++11 中比较有代表性的新特性有：智能指针、lambda表达式、范围 for 语句、auto、decltype、右值引用、std::move 函数、类的成员函数的 =default 和 =delete 声明等。
此外还有 override 关键字、constexptr 表达式、final 关键字、long long 类型等

### 左值和右值的区别？左值引用和右值引用的区别？
在C++中，左值（lvalue）和右值（rvalue）是两种基本的值类型，区别在于左值表示可以取地址且持久存在的对象，而右值表示临时的、不可取地址的值。
左值可以出现在赋值号的左侧或右侧，如变量int x = 10;中的x，而右值只能出现在赋值号的右侧，如int y = 5;中的5。
左值引用（lvalue reference）和右值引用（rvalue reference）是C++11引入的新特性，左值引用使用&表示，绑定到一个左值，可以通过引用修改该左值，例如int &ref = a;中的ref。
右值引用使用&&表示，绑定到一个右值，允许对临时对象进行修改和移动，常用于实现移动语义和减少不必要的拷贝，例如int &&rref = 10;中的rref。右值引用的应用包括移动语义，通过实现移动构造函数和移动赋值运算符，提高程序性能，避免不必要的深拷贝；以及完美转发，与模板结合使用，实现保持函数参数的值类别（左值或右值）。理解和使用左值、右值及其引用，可以帮助C++程序员更高效地管理资源，写出性能更优的代码。

### std::move函数的原理
首先移除引用，得到具体的类型。然后使用强制类型转换 static_cast 将其转换为右值引用。

### shared_ptr的线程安全性
官方对 shared_ptr 线程安全性的保证和其他所有 STL 容器、内置类型的保证是一样的：
同一个shared_ptr对象可以被多线程同时读取。
不同的shared_ptr对象可以被多线程同时修改，即使这些shared_ptr对象指向了同一个对象。
任何其他并发访问的结果都是未定义的。

### shared_ptr的原理
每个 shared_ptr 要维护两个指针：一个指向操作对象的指针，一个指向引用计数的指针。
shared_ptr 中的引用计数通过一个类 sp_counted_base（或者它的派生类）来维护的，该类中有两个计数器，一个 use_count 统计 shared_ptr 对象的数量，一个 weak_count 统计 weak_ptr 的数量。
所有指向同一个操作对象的 shared_ptr 都有一个指向同一个 sp_counted_base 对象的指针，对应的 weak_ptr 也会有一个指向该 sp_counted_base 对象的指针。

引用计数的修改本身是原子性的。
复制一次 shared_ptr 只会修改一次引用计数的值，因此多线程并发复制 shared_ptr 是安全的，但是一个线程复制，一个线程销毁（如调用 release 或指向其他对象）是不安全的。

### share_ptr可能出现并发问题的情况
风险情况：主要发生在引用计数归零要销毁对象的情况下。
例子：共享指针 A 指向了对象 obj，指向 obj 的只有这一个共享指针，现在 A 要指向其他对象了，而另一个线程中要新建一个共享指针 B 指向对象 obj，那么可能 B 先指向了对象 obj 尚未修改计数值时，线程就切换到了 A 这边，然后 A 将计数器减到了 0，并销毁了对象 obj。线程又切回 B 这边，B 这里就会出错，对象被意外销毁了。

风险情况：一个线程使用 weak_ptr 构造一个 shared_ptr 对象，另一个线程释放目前唯一存在的 shared_ptr。
因为基于 weak_ptr 构造 shared_ptr 需要先读一次计数器，然后构造 shared_ptr 时再修改一次计数器（增加计数），而在这两次操作的期间，可能另一个线程就把 shared_ptr 释放掉了，使得引用计数减为 0，然后销毁了 shared_ptr 管理的对象。

### 解决shared_ptr并发问题的方式
复制、修改 shared_ptr 时要加锁。

### 智能指针有哪几种？智能指针的实现原理？
有 shared_ptr, unique_ptr, weak_ptr, auto_ptr 四种，其中 auto_ptr 是 C++11 出来之前的智能指针，现在已经不用了：
shared_ptr：多个指针共享同一份资源，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。
unique_ptr：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。
weak_ptr：弱引用，指向 shared_ptr 所绑定的对象，访问对象前前要用 lock() 函数检查绑定的对象是否仍存在。
智能指针的实现原理：计数器。
实现一个智能指针需要定义：一个接受普通指针的构造函数、一个拷贝构造函数、一个拷贝赋值运算符、一个解引用运算符和一个成员访问运算符。内部维护一个 new 分配的对象和一个计数器。

### 一个 unique_ptr 怎么赋值给另一个 unique_ptr 对象
可以借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。
unique_ptr<A> ptr1(new A);
unique_ptr<A> ptr2 = std::move(ptr1);

### 使用智能指针会出现什么问题？怎么解决？
可能会出现循环引用的问题。
使用 shared_ptr 有可能出现循环引用的情况：定义了 A 类和 B 类，在 A 类中有个管理 B 类对象的共享指针，B 类中有个管理 A 类对象的共享指针，这时会因为 A、B 类的对象互相指向对方的内存空间，使得两者内存都无法释放，造成内存泄漏。
解决方式是其中一个使用 weak_ptr。

## 内存管理
### malloc/free 和 new/delete的区别是什么？
相同点： 
都在堆中申请空间，并且需要用户手动释放

不同点：
1. malloc和free是函数，new 和delete是操作符
2. malloc申请的空间不会初始化，new可以，new在申请空间后会调用构造函数完成对象的初始化，delete会在释放空间前调用析构函数完成空间中的资源清理
3. malloc申请空间时，需要手动计算空间的大小并传递，new只需要在其后面跟上空间的类型即可
4. malloc的返回值是void*,在使用时必须做强制转换，new不需要
5. new/delete效率比malloc/free低，new/delete的底层封装了malloc/free

###  C++如何实现只在栈上实例化对象？
只能在栈上创建对象也就是说不能在堆上创建对象，因为用new在堆上创建对象分为两步，因此只要让new不能调用operator new库函数就可以了，因此只要自己在类内重载一个operator new函数，并将其声明为私有的即可。
注意：重载了operator new也必须重载operator delete

### C++ 如何让一个类只在堆上创建对象?

想法一：如果只能在堆上创建对象的话也就意味着不能在栈上创建对象，而我们知道要创建对象必须调用类的构造函数，在这里有很多人就会想到将构造函数设置为私有的，这样一来就只能通过new来创建对象，可是一旦将构造函数设置为私有的new也无法对对象进行初始化了。
new为创建对象需要两步，即先调用库函数operator new开辟空间，后调用类的构造函数对空间进行初始化。此时如果将构造函数设置为私有的，new就无法初始化对象了，只能为对象分配空间。

想法二：其实在创建对象的时候，编译器会先检查类的析构函数能否调用，因为编译器要保证开辟出去的空间要能回收回来呀，所以此时如果将类的析构函数设置为私有的，就编译器就不会调用类的构造函数在栈上创建对象了。但是问题又来了，一般析构函数是要在对象的生命周期完结之后进行一些清理工作的，即如果使用new运算符在堆上开辟空间了，析构函数中必然要用delete对空间进行释放，如果将析构函数设置为私有的，就不能将堆上申请的空间释放掉了，此时可以将delete定义在类的一个公有成员函数中，在类外显示地调用一下这个成员函数就可以将堆上申请的空间释放掉了。
注意：必须要在类内的成员函数内使用delete来释放空间，因为如果在类外使用delete来释放空间的话，delete就会调用类的析构函数，此时析构函数是私有的，不能进行调用，而在类内疚可以进行调用了。

### 函数栈帧的内容


一般给一个指针开辟空间后需要主动释放内存，如果已知一个对象的生命周期很短，如何写一个工具类能够帮助释放内存？
可以使用智能指针，或者为类添加引用计数功能。

是否了解内存模型？（提示如果写一个类的实例对象，那么在内存中分为哪几个部分？）（提示常量、静态变量、虚函数表）（提示new产生一个对象时，内存模型是怎么样的？）

### C++ 空类的 sizeof 大小
空类的 sizeof 大小是 1，因为每个对象必须有一个互相区别的地址，所以编译器会强制它是非零长度。
如果类有一个非虚函数，它的 sizeof 大小也是 1，如果类有一个虚函数，它的大小是 8 字节，这是 VPTR 指针的长度。

### 类大小的计算
计算原则：遵循结构体的对齐原则。
影响类大小的因素：非静态成员变量、虚函数、虚继承。虚函数的影响是因为虚表指针，虚继承的影响是因为它继承包含虚函数的基类带来了虚表指针。
不会影响类大小的因素：非虚函数（包括普通成员函数和静态成员函数）、静态成员变量

### 什么是内存对齐？
内存对齐主要是为了提高访问效率，此外还能提高程序的可移植性。一些硬件平台只能从特定地址开始读取，比如必须从偶地址开始读，这时在访问不对齐的字节时要多次访问才能读取完成。
联合是按其包含的长度最大的数据类型对齐。
常说的字节对齐很多时候指的是结构体的内存对齐。
结构体的内存对齐遵循三个原则：
结构体变量的起始地址能够被其最宽的成员大小（与对齐基数两者间的较小者）整除；
结果提的每个成员相对起始地址的偏移能够被其自身大小（与对齐基数两者间的较小者）整除，如果不能则在前一个成员后面补充字节；
注意：虚函数的 VPTR 也在此之内，VPTR 占 8 字节，因此它的偏移必须是 8 的整数倍。
结构体总体大小是最宽的成员的大小（与对齐基数两者间的较小者）的整数倍，如果不能则在后面补充字节。
一般默认对齐大小（对齐基数）是 4 字节，实际采用的有效对齐是指定大小和自身大小的较小者。
默认对齐大小是可以修改的，使用 #progma pack(n) 来指定默认的对齐大小。

### 结构体字节对齐问题
见上一问题
struct Pet {
    char b;
    int a;
    short c;
}; // 总共占 12 字节
struct Pet{
    int a;
    char b;
    short c;
}; // 总共占 8 字节

### 堆和栈有什么区别？
控制权：堆由程序员分配和释放，栈由编译器自动分配和释放；
空间大小：栈是向低地址扩展的，是连续的内存区域，栈顶的地址是确定的；堆是向高地址扩展的，是不连续的内存区域，系统是用链表来存储空闲的堆空间的，堆的大小由计算机的有效虚拟内存决定，要比栈大得多。
堆分配内存的过程：在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，将该块空间上的剩余空间再次连接在空闲链表上。
速度：栈得分配比较快，堆慢一些，但使用方便；
系统响应：使用栈时如果剩余空间不足，会有栈溢出的异常提示。
存储内容：栈中除了存储局部变量外，还要存储函数返回地址、函数参数等，而堆的存储内容完全由程序员决定。

### 什么是内存泄漏
1. 堆内存泄露
内存泄漏：未释放已经不再使用的内存。
常见原因：new 后没有 delete，将原本指向 new 分配的指针指向了其他对象等。总之只要 new 了没有 delete 就会内存泄漏。
```c++
int* p3=new int[10];

Func();//Func()抛出异常导致delete[]这条语句未执行，导致p3未被释放

delete[] p3;
```
2. 系统资源泄露
指程序使用系统分配的资源，比如套接字、文件描述符、管道等没有使用对应的函数释放掉，导致系统资源浪费

### 如何避免内存泄漏
使用智能指针。
如果不使用智能指针，也可以编写具有计数功能的类来实现对应功能。但是建议优先使用智能指针。

### 内存泄漏怎么检测
使用内存检测工具，如 valgrind。
valgrind 是一套 Linux 下的仿真调试工具的集合，包括以下工具：
Memcheck：内存检查器（valgrind 应用最广泛的工具），能够发现开发中绝大多数内存错误的使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。
Callgrind：检查程序中函数调用过程中出现的问题。
Cachegrind：检查程序中缓存使用出现的问题。
Helgrind：检查多线程程序中出现的竞争问题。
Massif：检查程序中堆栈使用中出现的问题。
Extension：可以利用 core 提供的功能，自己编写特定的内存调试工具
Memcheck 能够检测出内存问题，关键在于其建立了两个全局表：
Valid-Value 表：对于进程的整个地址空间中的每一个字节（byte），都有与之对应的 8 个 bits ；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。
Valid-Address 表：对于进程整个地址空间中的每一个字节（byte），还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。
检测原理：
当要读写内存中某个字节时，首先检查这个字节对应的 Valid-Address 表中对应的 bit。如果该 bit 显示该位置是无效位置，Memcheck 则报告读写错误。
当内存中的某个字节被加载到真实的 CPU 中时，该字节在 Valid-Value 表对应的 bits 也被加载到内核中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 Memcheck 会检查 Valid-Value 表对应的 bits，如果该值尚未初始化，则会报告使用未初始化内存错误。

### 不同类型变量的区别及所在内存空间
C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。
四种变量在作用域上的区别：
全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。但是其他源文件需要用 extern 关键字再次声明这个全局变量。
静态全局变量：具有文件作用域。作用域仅限定义它的文件，不能作用到其它文件里。不同文件可以定义相同名字的静态全局变量。
局部变量：具有局部作用域。只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。
静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，静态局部变量只对定义自己的函数体始终可见。
从分配内存空间看：
静态存储区：全局变量，静态局部变量，静态全局变量。
栈：局部变量。
说明：
静态变量和栈变量、堆变量的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。

### 全局变量可以定义在头文件中吗？
不可以，如果在头文件中定义全局变量，当该头文件被多个文件 include 时，该头文件中的全局变量就会被定义多次，导致重复定义。
解决方法：在头文件中用 extern 声明，在源文件中定义。

### 限制对象只能创建在堆上的方式
两种方法：
方法1：将析构函数设为私有。在栈上创建对象时，由编译器负责分配和释放内存空间，而编译器在为对象分配内存空间时，会检查类的非静态函数，包括检查析构函数的可访问性。当析构函数为私有，编译器就无法通过访问析构函数来释放空间，所以此时编译器不会在栈上为对象分配内存。
缺点1：需要定义一个 public 的 destory() 成员函数来完成对象的释放。因为 new 创建的对象通常要用 delete 来释放对象，而这时析构函数无法调用，因此必须定义一个 destory() 成员函数来释放对象。
缺点2：无法解决继承问题。当此类作为基类时，它的派生类无法访问它的析构函数。
方法2：构造函数和析构函数都设为 protected，并定义一个 public 的静态函数来完成构造，而不是在类外用 new 构造。再定义一个 destory() 非静态函数来释放对象。
'方法1'
class A{
public:
    void destory() { delete this; }
private:
    ~A() { }        
};

int main(){
    A a;  // 错误，不用运行编译器就会直接提示语法错误：~A() 无法访问。
}

'方法2'
class A {
protected:
    A() { }
    ~A() { }
public:
    static A* create() { return new A(); }
    void destory() { delete this; }        
};

### 限制对象只能创建在栈上的方式
将 operator new() 和 operator delete() 函数设置为私有。原因：使用 new 分配对象时底层是通过调用 operator new() 函数来实现的，因此通过限制该函数的访问权就可以防止对象建立在堆上。
class A {
private:
    void *operator new(size_t t) { }
    void operator delete(void *ptr) { }   // 定义 delete 的原因是一般重载了 new 同时也要重载 delete。
public:
    A() {}
    ~A() {}    
}

## 关键字
`指针和引用`
### 定义常量指针和指针常量
int num = 1;
const int* p = &num; // 常量指针是底层 const，即不能通过指针来改变指向的对象的值，但是可以改变指针本身的值，即更改指针指向的对象。
int* const p = &num; // 指针常量顶层 const，即指针本身是一个常量，无法修改指针指向的对象，但是可以修改指针指向的对象的值。 

### 你刚刚说了野指针和悬空指针，说说什么是野指针？悬空指针？
野指针是未初始化的指针。
悬空指针是 C 语言中使用 free 释放了内存的指针。正确操作：free 后就将指针的值设为 NULL。

### 引用和指针的区别？
指针是对象，引用不是对象。
指针可以不进行初始化，引用必须初始化。
指针可以重定向，引用不能重定向。
指针是一种类型，占 8 字节空间。
指针有多层指针，引用没有。
修改引用修改的是引用绑定的对象的值，修改指针修改的是指针的地址。
相同处：在汇编层引用也是通过指针实现的。

### 从汇编层解释一下引用
从汇编的角度指针和引用是一样的。引用就像是可以自动地被编译器解引用的常量指针。引用相比指针使语法更便利。

### C++中的指针参数传递和引用参数传递
根据引用和指针的区别来说即可。

### static的用法和作用？
static 使用的场合可以分为三个地方：
全局。使用 static 修饰全局变量可以起到隐藏的作用，就是将全局变量的可见范围缩小到本文件内。这样不容易出现命名冲突。
局部。使用 static 修饰局部变量可以起到延长变量生命周期的作用，使用 static 修饰局部变量，该变量的生命周期会延长到程序执行结束。使用 static 修饰的局部变量也会默认初始化为 0。
类内。包括 static 成员函数和 static 成员变量。它们都属于整个类不属于某个对象。static 成员函数不能使用 this 指针，因此也不能访问类的非 static 数据成员。
在内存中 static 修饰的变量位于静态存储区，会在程序开始执行时进行初始化。

`静态变量`
### 静态变量什么时候初始化？
在程序开始执行时进行初始化。

### static与普通函数变量的区别？常量存储在哪里？static变量又是存储在哪里？

### extern

`类型转换`
### dynamic_cast有什么作用
dynamic_cast 用于向下类型转换，将基类的引用或指针转换为指定派生类的引用或指针，当类型转换是正确的且成功的时，返回值是一个指向所需类型的指针，否则将返回 0。
dynamic_cast 操作的场景必须是一个真正多态的层次（即使用了虚函数），因为 dynamic_cast 使用了存储在 VTABLE 中的信息来判断实际的类型。
无论何时执行向下类型转换，都需要检验类型转换的返回值是否为 0。

static_cast
主要用于基本数据类型之间的转换，如把 uint 转换为 int，把 int 转换为 double 等。
static_cast 还可用于类层次结构中，基类和派生类之间指针或引用的转换，但也要注意：
static_cast 进行上行转换是安全的，即把派生类的指针转换为基类的；
static_cast 进行下行转换是不安全的，即把基类的指针转换为派生类的。
dynamic_cast
dynamic_cast 主要用于类层次间的上行转换或下行转换。在进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的，但在下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。
在进行下行转换时，转换失败会返回空指针，这正是 dynamic_cast 提升安全的功能。这个检查主要来自虚函数表。
注意：以下
Derive* d1 = new Derive();
Base* b1 = dynamic_cast<Base*>(d1); // 下行转换成功，因为 d1 指向的是派生类对象

Base* b2 = new Base();
Derive* d2 = dynamic_cast<Derive*>(b2);  // 下行转换会失败
这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。
const_cast
该运算符用来修改 expression 的 const 或 volatile 属性。
const int* px = &x;
int* py = const_cast<int*>(px);
reinterpret_cast
该运算符可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。
这个转换是“最不安全”的。不推荐使用。
int* p = new int(5);
uint64_t p_val = reinterpret_cast<uint64_t>(p);
总结
static_cast：基本类型转换，低风险；
dynamic_cast：类层次间的上行转换或下行转换，低风险；
const_cast：去 const 属性，低风险；
reinterpret_cast：转换不相关的类型，高风险。

### const成员函数的理解和应用？
一般将不会修改类的成员变量的函数声明为 const 成员函数。
const 成员函数中只能访问类的 const 数据成员。
使用 const 成员函数一方面是为了保证安全，另一方面可以提醒读者这个函数不会修改类的数据成员

`inline函数`
### inline的作用
inline 声明的是内联函数，内联函数在使用时直接将函数体在调用处展开，向宏一样。普通函数调用时需要进行返回地址和参数的入栈和出栈等一系列操作才能完成对函数的调用，而内联函数没有了这一开销，因此速度更快。
但是也要注意只有那些体积较小的函数适合声明为内联函数，否则会浪费内存。

### define 和 inline 区别。
C++ 引入 inline 的主要原因就是用来代替 define 的， inline 比 define 安全的多。
inline 会检查参数的类型、返回值类型等。

## 编译和链接
### C++ 程序编译过程
预处理->编译->汇编->链接

### 静态链接与动态链接的特点、优缺点比较

### 多个动态库的链接顺序由区别吗？顺序怎么排？

## 多线程
### 多线程同步的方式有哪些？

## 设计模式
设计模式了解哪些？（针对回答）单例模式中双检索如果变成一次会有什么影响？
单例模式、三种工厂模式、观察者模式等。
用过单例模式。

### 什么是单例模式
单例模式是一种创建型模式。
用处：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
优点：可以避免一个全局使用的类频繁地创建和销毁。
单例模式有不同地实现方式：懒汉模式：多线程不安全。饿汉模式：多线程安全。
饿汉模式：类加载时就初始化，会浪费内存。
懒汉模式：有用户访问 getInstance() 时才初始化，节省内存。

### 什么是工厂模式
工厂模式是一种创建型模式。

### 什么是观察者模式
观察者模式用于对象之间存在一对多的依赖关系的时候。比如当一个对象被修改时，则会自动通知依赖它的对象。
一般通过三种类来实现，subject 类、obeserver 类，client 类。

### 什么是生产者、消费者模式

## 语言对比
### Java和C++的区别
`每个语言有自己的优势和生态，做什么应用觉得你使用哪些语言`
第一部分，语法：
1. 指针与引用。C++ 类型，值，引用，左值，右值，指针
2. 多重继承
3. 自动内存管理，对象创建， jave用new,C++堆/栈 RAII
4. 操作符重载
5. 预处理 #
6. 类型转换，C++存在隐式转换 RTTI
7. 异常
8. java 纯OO， 不支持全局函数，C++多编程范式
9. 面向对象，C++ 用virtual ,JAVA默认都是virtual, 纯虚函数和接口
10. callback回调的实现，lambada ,bind
11. 字符串，java是定长的
12. boolean C++非0

第二部分，生态：
1. 平台移植
C++ 平台差异 linux,window ，C++ 中内存大小可能不一样size of ，GCC,CLANG,VC++
java jvm 跨平台
2. 外部库
C++库：C++ QT,STL,boost
JAVA 库：数据库，网络，IO,并发,thread，网络 TCP/HTTP
3. 工具链
C++ vscode visual studio
java IDEA

第三部分，应用领域：
操作系统 linux  --> C
Office -->
编译器 --> 蓝色
服务器后端 -->
游戏开发 -->
web 后端--> java