### 剑指offer

优先队列和堆
双向链表
平衡二叉树
二叉搜索树



算法

- 二分搜素
- 回溯法（DFS）
- BFS
- 动态规划

对称

- DFS和BFS
- 顺序存储和链式存储
- 自下而上（循环） 自上而下（递归）
- 实践->量变->质变->认识->实践

术
- 调试。循环结构和递归结构，断点法和log法，全局和细节

#### 1 数据结构
**offer 05**
**offer 06**
**offer 09**


#### 2 查找算法

**offer 04**

- 2分查找的矩阵形式，两个方法

#### 3 排序

**offer 40**

- 排序的基础操作是数据交换
- 快速排序和二份查找之间的联系

**offer 41**

- 优先队列

**offer 45**

- 重新定义数据大小的metric

**offer 61**

#### 4 双指针
- 一般应用于数组，链表，字符串的题目

**offer 18**

- 链表 头节点，尾节点的特殊情况

- 链表的遍历（单指针和双指针）

- 链表的删除操作


- 链表的表示方法只用head就可以表示一个链表， （字符串和数值， 只用指针表示）

**offer 21**

- quick sort 中交换的metric, 以大小为metric，以奇偶为metric

**offer 22**

- 链表查找和链表size的关系

**offer 25**

- 链表成员val的赋值 和 指针的赋值的区别  

- if else 中都要执行的操作放在条件判断的外面

**offer 52**

- 复制链表和原链表 = copyA 和 = A

**offer 57**
- for 循环中，小于size()和小于等于size()-1 这两个边界是一致的
- 注意数值这个递增条件

**offer 58-1**

- if和 while ，只执行一次用if，可能执行多次用while

#### 5 搜索与回溯算法

觉得树很难，先用分而治之的办法想想，能不能拆解为基本概念，基本性质和基本问题

- 二叉树算法的返回值特点。遍历是树转化为向量，重构是向量转为树。还可以把树直接转为另一个树
- 递归中的return 语句，如果return 整型会怎么样，return void会怎么样，函数栈怎么传递return的结果
- DFS 决策树 路径 选择列表 剪枝 回溯 

**offer 12 矩阵中的路径**

- 二维数组的遍历与多叉树的遍历的关系
- 二维矩阵的下标与树的指针，数组前后-->上下左右，双向链表pre/next-->左子树/右子树
- 顺序存储和链式存储
- k值怎么加1
- 回溯法的几个普遍问题
  - 找到一条可行路径就退出
  - 剪枝

**offer13 机器人的运动范围**

- (子问题)数位和的求法，数位增量公式
- 怎么把一个矩阵看做一个抽象的二叉树
- 显式metric1-位数和，隐式metric2-无法跨越obstacle
- dfs 和 bfs

**offer 26 二叉树的子树**

- 叶子节点和底层叶子节点的特点

- 怎么一个树是另一个树的子树

- 二叉树的遍历只能一个一个遍历，但为了缓存数据，需要将左子树或右子树缓存，

  对于深度优先（先序，中序，后序），有下层节点先与上层节点被访问，可能会用到栈

- 对于广度优先，需要用到队列

- 树的遍历中递归算法应用于查找子树

**offer 27 二叉树镜像** 

- 二叉树的镜像与层次遍历的逆序

**offer 28 对称的二叉树**

**offer 32-1**二叉树层次遍历

- 关注visit 向量和queue中存的值

- 根判空返回

  队列先进根

  循环取队头

  进值看左右

**offer 32-2** 二叉树按层打印

- queue  的size() 方法 
- 怎么知道当前遍历到哪一层

**offer 32-3** 二叉树蛇形打印

- 怎么判断在奇数层还是在偶数层
- 空层怎么保证不打印出来

**offer 34** 二叉树的路径

- vector的pop_back(),参数为void,与stack的pop()方法不同
- 树的路径搜素 -> 先序遍历的递归版本的变种

```c++
recur(root->left, tar);
recur(root->right, tar);
path.pop_back();
```

- 双重递归函数的调用顺序-->树的遍历的递归方法其实也是双重递归问题
- 递归函数后面的语句什么时候执行 recur; statement;

**? offer 36 二叉搜索树和双向链表**

- 对二叉搜素树进行中序遍历可以得到有序
- 构建链表时使用双指针
- 双向链表的定义，怎么通过一个head来表示一个双向链表

**offer 37 序列化二叉树**

- (子问题)字符串的spilit-->双指针
- 树节点的创建，new TreeNode*

**offer 38 字符串的排列**

- 全排列问题

**offer 54 二叉搜索树的第 k 大节点**

- 遍历完再取值，和边遍历边比较
- 递归中找到对应的值怎么退出递归

**offer 55a 二叉树的深度**

**offer 55b 平衡二叉树**

- 递归有返回值

**offer 64 求1到n的和**

**offer 68 最近公共祖先**

- 最近公共祖先的定义
- 最近公共祖先的情况遍历
- 与链表的公共节点的联系

#### 6 搜索与回溯算法

**offer 07 重建二叉树**

- 中序+先序/后序可重建，必须包含中序

- 重建二叉树关键在于怎么计算递归参数，本题中有3个递归参数:root,left,right

- 在preorder list中确定root的位置，通过root新建二叉树节点-->参数root

- 在inorder list确定左/右子树元素的数量-->参数left,right

- inorder 和 preorder里元素都是相同，重建二叉树需要同时参考这两个列表，两者关联点在于元素，所以把元素作为hashmap的key

- 右子树的根节点索引：根节点索引 + 左子树长度 + 1

  ```
  先序遍历用来确定根的位置；
  中序遍历用来确定左右子树的数量；
  在递归体中，root表示根的位置in preorder；
  left和right表示左右子树的边界in inorder;
  用到了三次recur，其中参数分别表示：
  
  recur(0,0,len(inorder)-1):本句为建立整棵二叉树，pre[0]为根元素，在inorder中左边界和 右边界分别是整个数组的左右边界
  
  node.left = recur(root+1,left,i-1)：本句为建立左子树，左子树的根在整棵树根的下一个位置（在preorder中找位置）即root+1；左子树的左边界仍为原树的左边界；左子树的右边界在inorder中位于根元素位置的左侧一个，即i-1
  
  node.right = recur(i-left+root+1,i+1,right):本句为建立右子树，右子树的根的位置需要在原树根位置root的基础上加上左子树的元素个数i-left的下一位置（在preorder中找位置）,即root+(i-left)+1；右子树的右边界仍为原树的右边界；右子树的左边界在inorder中位于根元素位置的右侧一个，即i+1
  ```

  

